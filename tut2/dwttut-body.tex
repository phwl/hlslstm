
\section{Introduction}
Complex waveforms can be decomposed into harmonic components using
the discrete Fourier transform. Similarly, they can be decomposed
into a sum of Walsh functions via a discrete Wavelet transform
(DWT).  In this laboratory, we will develop a DWT accelerator.
The explanation of the FWT algorithm below follows that of Beauchamp~\cite{beauchamp1975walsh}.

\subsection{Definitions}
A real series $S_n(t), n=(0,1,\ldots)$, is {\em orthogonal} 
with weight $K$ over the interval $t \in [0, T]$ if
\begin{equation}
\int_0^T K S_n(t) S_m(t) dt = \begin{cases}
K & \text{if $n=m$}\\
0 & \text{if $n \ne m$}\\
\end{cases}
\end{equation}
where $n$ and $m$ are integers, and $K$ is a non-negative constant.
If $K = 1$, it is an {\em orthonormal} series.

For an orthogonal $S_n(t)$, a time-varying function, $f(t), t \in (0,T)$ 
can be represented as:
\begin{equation}
f(t) = \sum_{n=0}^\infty C_n S_n(t)
\label{eq:rep}
\end{equation}
where $C_n \in \cal{R}$.

In a practical implementation, the sum in Equation~\ref{eq:rep} must
be finite, and the mean-squared approximation error is
\begin{equation}
E = \int_0^T [f(t) - \sum_{n=0}^N C_n S_n(t)] dt
\label{eq:error}
\end{equation}
which is minimised by setting
\begin{equation}
C_n = \frac{1}{T} \int_0^T f(t) S_n(t) dt.
\end{equation}

A function set is {\em complete} if Equation~\ref{eq:error} converges
monotonically to zero with $N$. Examples of complete function sets
include the Fourier series and the Walsh series. An example of an
orthogonal function set which is not complete are the Rademacher
functions.

\subsection{Walsh functions}
An alternative to expressing the Walsh functions in terms of Rademacher
functions as described previously, is in the form of the continued product:
\begin{eqnarray}
WAL(n, t) & = & W_n(t/T) \\
 &=& WAL(n_{p-1}, n_{p-2}, \ldots, n_0; t_{p-1}, t_{p-2}, \ldots, t_0) \\
 &=& \prod_{r=0}^{p-1} (-1)^{n_{p-1-r} (t_r + t_{r+1})}
\end{eqnarray}
where $t \in \{0,1,\ldots,T\}$; and
$(n_{p-1} n_{p-2} \ldots n_0)_2$ 
and $(t_{p-1} t_{p-2} \ldots t_0)_2$ are the 
binary representations of the $p$-bit unsigned integers $n$ and $t$. 

\subsection{Discrete Walsh Transform}
A Lebesque integrable function $f(t), t \in (0,1)$ can be represented 
by a Walsh series over $(0,1)$ as
\begin{equation}
x(t) = a_0 + a_1 WAL(1, t)) + a_2 WAL(2, t)) + \ldots
\end{equation}
where $a_k=\int_0^1 f(t) WAL(k, t) dt$. The Walsh transform pair can then
be defined as:
\begin{eqnarray}
f(t) & = & \sum_{k=0}^\infty F(k) WAL(k, t)\\
F(k) & = & \int_0^1 f(t) WAL(k, t) dt.
\end{eqnarray}

For the discrete case, the trapezium rule can be applied 
with $N=2^p$ (where $p$ is a non-negative integer) sampling points $x_i$
to give the finite linear DWT transform pair:
\begin{eqnarray}
X_n &=& \frac{1}{N} \sum_{i=0}^{N-1} WAL(n, i) x_i,\; i = 0, 1, \ldots, N-1\\
x_i &=& \sum_{n=0}^{N-1} WAL(n, i) X_n,\; i = 0, 1, \ldots, N-1.
\end{eqnarray}
where $WAL(n, x)$ is the Walsh function defined in the previous tutorial.
It is important to note that:
\begin{itemize}
\item The computation involved is simply an $N\times N$ matrix-vector multiplication
with the Walsh matrix 
$W_N = [WAL(0,t); WAL(1,t), \ldots, WAL({N-1},t)]\; t=0, 1, \ldots, N-1$.
\item Since $WAL(n,t)$ only takes the values $\{-1,+1\}$, transforms
can be computed using only subtraction and addition.
\item Both the forward and inverse transform are the same computation
with different scaling factors.
\end{itemize}

\subsection{Examples}
The 8-point DWT of $x=(0, 1, 2, 3, 4, 5, 6, 7)^T$ is
\begin{eqnarray}
X &=& W_8 x\\
 &=& \left( \begin{array}{cccccccc}
1& 1& 1& 1& 1& 1& 1& 1\\
1& 1& 1& 1&-1&-1&-1&-1\\
1& 1&-1&-1&-1&-1& 1& 1\\
1& 1&-1&-1& 1& 1&-1&-1\\
1&-1&-1& 1& 1&-1&-1& 1\\
1&-1&-1& 1&-1& 1& 1&-1\\
1&-1& 1&-1&-1& 1&-1& 1\\
1&-1& 1&-1& 1&-1& 1&-1
\end{array} \right)
\times \left( \begin{array}{c}
0\\
1\\
2\\
3\\
4\\
5\\
6\\
7
\end{array} \right) \\
 &=& 
\left( \begin{array}{cccccccc}
3.5 & -2.0 & 0.0 & -1.0 & 0.0 & 0.0 & 0.0 & -0.5
\end{array} \right)^T
\end{eqnarray}

The inverse DWT of 
$X=\left( \begin{array}{cccccccc}
(3.5 & -2.0 & 0.0 & -1.0 & 0.0 & 0.0 & 0.0 & -0.5)^T
\end{array} \right)$
is
\begin{eqnarray}
W_8 X &=& \left( \begin{array}{cccccccc}
1& 1& 1& 1& 1& 1& 1& 1\\
1& 1& 1& 1&-1&-1&-1&-1\\
1& 1&-1&-1&-1&-1& 1& 1\\
1& 1&-1&-1& 1& 1&-1&-1\\
1&-1&-1& 1& 1&-1&-1& 1\\
1&-1&-1& 1&-1& 1& 1&-1\\
1&-1& 1&-1&-1& 1&-1& 1\\
1&-1& 1&-1& 1&-1& 1&-1
\end{array} \right)
\times \left( \begin{array}{c}
3.5 \\
 -2.0 \\
 0.0 \\
 -1.0 \\
 0.0 \\
 0.0 \\
 0.0 \\
 -0.5
\end{array} \right) \\
 &=& 
\left( \begin{array}{cccccccc}
0 & 1 & 2 & 3 & 4 & 5 & 6 & 7
\end{array} \right)^T\\
 &=& x
\end{eqnarray}

\section{Laboratory Questions}
\begin{enumerate}
\item Discrete Walsh transform processor (30\%). 
Make a combinatorial, parallel implementation of an $N=64$ DWT processor
for the Altera Cyclone V 5CSEMA5 FPGA used in the DE1-SoC board.
Your inputs should be 16-bit integers in two's complement form, and
your output represented as a two's complement fraction with sufficiently
large wordlength that overflow cannot occur. 

Create a set of random test vectors and verify that your design is
correct via simulation. The FPGA design tools report the maximum
clock rate, $f_{max}$ which can be achieved by your design. What is this
value? The 
maximum throughput is thus $2Nf_{max}$ bytes/sec. Calculate the
throughput of your design.

\item Pipelined DWT processor (30\%). 
Modify your DWT processor so that it is pipelined and verify via
simulation. What is the new design's
maximum throughput? What is the speedup compared with the non-pipelined design?

\item Multicycle execution (40\%). 
It may not be feasible to supply the DWT processor with 64 high-speed,
parallel inputs. Develop a modified version of the DWT processor
which takes 2 inputs samples per cycle, i.e. it takes $N/2$ cycles
to obtain a complete input vector. Redesign your processor
so that it minimises the area-delay product (area being measured in
LUTs) and can process streaming input data without stalling.
What is the maximum performance in bytes/sec?

\item Comparison (bonus 20\%). 
Integrate the DWT processor with an linear feedback shift register based
random number generator which is used as the source of the input
data. Implement the design in hardware and verify its correct operation.
Identify the sources of bottlenecks in your design.

\end{enumerate}

